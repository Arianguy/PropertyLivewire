# docker-compose.yml - Enhanced for Production Considerations
version: "3.8"

services:
    # PHP Service (Application Server for HTTP requests)
    app:
        build:
            context: .
            dockerfile: docker/php/Dockerfile # PRODUCTION Dockerfile needed here
            args:
                UID: ${UID:-1000} # Ensure permissions match host if needed, less critical if image builds everything
                GID: ${GID:-1000}
                # Consider adding build args like APP_ENV=production
        container_name: propertylivewire-app
        restart: unless-stopped
        working_dir: /var/www/html
        volumes:
            # Mount code primarily for development; in production, code should be baked into the image.
            # Consider removing or making this read-only in pure production image deploys.
            - ./:/var/www/html
            # Mount storage/logs if they shouldn't be baked into the image or lost on restart
            # - ./storage:/var/www/html/storage
            # - ./bootstrap/cache:/var/www/html/bootstrap/cache # Only if not cached during build
        environment:
            # Pass essential runtime env vars; sensitive ones should use secrets
            APP_ENV: production
            APP_DEBUG: "false"
            APP_KEY: ${APP_KEY} # MUST be set in .env or injected
            DB_CONNECTION: mysql
            DB_HOST: db
            DB_PORT: 3306
            DB_DATABASE: ${DB_DATABASE:-propertylivewire}
            DB_USERNAME: ${DB_USERNAME:-sail}
            DB_PASSWORD: ${DB_PASSWORD_SECRET:-secret} # Use secret mechanism
            REDIS_HOST: redis
            REDIS_PORT: 6379
            # Add other necessary runtime env vars (MAIL_*, AWS_*, etc.)
        networks:
            - propertylivewire-network
        depends_on:
            db:
                condition: service_healthy # Wait for DB to be ready
            redis:
                condition: service_healthy # Wait for Redis to be ready
        healthcheck:
            # Basic check: Can PHP-FPM be reached? Add a dedicated healthcheck endpoint in Laravel for better checks.
            test: ["CMD", "cgi-fcgi", "-bind", "-connect", "127.0.0.1:9000"]
            interval: 10s
            timeout: 5s
            retries: 3
            start_period: 30s # Give time for PHP-FPM to start

    # Nginx Service (Web Server)
    nginx:
        build:
            context: ./docker/nginx # Separate Dockerfile for Nginx possible
            dockerfile: Dockerfile # Or use image: nginx:1.25-alpine (specify version)
        container_name: propertylivewire-nginx
        restart: unless-stopped
        ports:
            # Expose internal port 80. Map 443 if handling SSL here.
            - "${APP_PORT:-80}:80"
            # - "443:443" # Uncomment if handling SSL directly in this container
        volumes:
            - ./:/var/www/html:ro # Mount code read-only
            - ./docker/nginx/production.conf:/etc/nginx/conf.d/default.conf:ro # Use a production-optimized Nginx config
            # Add volumes for SSL certificates if handling SSL here
            # - /path/to/certs:/etc/nginx/certs:ro
        networks:
            - propertylivewire-network
        depends_on:
            - app

    # MySQL Database Service
    db:
        image: mysql:8.0 # Use specific versions
        container_name: propertylivewire-db
        restart: unless-stopped
        command: --default-authentication-plugin=mysql_native_password # Ensure compatibility if needed
        environment:
            MYSQL_DATABASE: ${DB_DATABASE:-propertylivewire}
            MYSQL_USER: ${DB_USERNAME:-sail}
            MYSQL_PASSWORD_FILE: /run/secrets/db_password # Use Docker Secrets for password
            MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password # Use Docker Secrets
        secrets: # Define secrets to be used
            - db_password
            - db_root_password
        ports:
            # Only expose if needed for direct access from host (e.g., debugging)
            # Consider removing for production if only app needs access
            - "${FORWARD_DB_PORT:-3306}:3306"
        volumes:
            - propertylivewire-db-data:/var/lib/mysql
            # Optional: Mount custom MySQL config
            # - ./docker/mysql/my.cnf:/etc/mysql/conf.d/custom.cnf:ro
        networks:
            - propertylivewire-network
        healthcheck:
            test: [
                    "CMD",
                    "mysqladmin",
                    "ping",
                    "-h",
                    "localhost",
                    "-u${DB_USERNAME:-sail}",
                    "--password=${DB_PASSWORD_SECRET:-secret}",
                ] # Adjust user/password if using secrets properly
            interval: 10s
            timeout: 5s
            retries: 5

    # Redis Service (Cache/Queue)
    redis:
        image: redis:7-alpine # Use specific versions
        container_name: propertylivewire-redis
        restart: unless-stopped
        command: redis-server --save 60 1 --loglevel warning # Basic persistence and logging
        # Add password protection:
        # command: redis-server --requirepass ${REDIS_PASSWORD_SECRET} --save 60 1 --loglevel warning
        # environment:
        #   REDIS_PASSWORD_SECRET: ${REDIS_PASSWORD_SECRET} # Use secret mechanism
        #ports:
        # Only expose if needed for direct access from host
        # - "${FORWARD_REDIS_PORT:-6379}:6379"
        volumes:
            - propertylivewire-redis-data:/data
        networks:
            - propertylivewire-network
        healthcheck:
            test: ["CMD", "redis-cli", "ping"]
            interval: 10s
            timeout: 5s
            retries: 5

    # Laravel Queue Worker Service
    worker:
        build: # Same build as app, ensures code and env match
            context: .
            dockerfile: docker/php/Dockerfile # PRODUCTION Dockerfile
            args:
                UID: ${UID:-1000}
                GID: ${GID:-1000}
                # APP_ENV: production # Could be set here too
        container_name: propertylivewire-worker
        restart: unless-stopped
        working_dir: /var/www/html
        # Run the worker command; entrypoint in Dockerfile could handle waiting for DB/Redis
        command: "php artisan queue:work redis --queue=default --tries=3 --timeout=90 --sleep=3"
        volumes: # Similar considerations as 'app' service regarding code mounting
            - ./:/var/www/html
        environment: # Inherit necessary vars, override if needed
            APP_ENV: production
            APP_DEBUG: "false"
            APP_KEY: ${APP_KEY}
            DB_CONNECTION: mysql
            DB_HOST: db
            DB_DATABASE: ${DB_DATABASE:-propertylivewire}
            DB_USERNAME: ${DB_USERNAME:-sail}
            DB_PASSWORD: ${DB_PASSWORD_SECRET:-secret}
            REDIS_HOST: redis
            REDIS_PORT: 6379
            QUEUE_CONNECTION: redis
        networks:
            - propertylivewire-network
        depends_on: # Needs code, db, and redis to function
            app: # Depends on build primarily
                condition: service_started # Or service_healthy if app has reliable healthcheck
            db:
                condition: service_healthy
            redis:
                condition: service_healthy

    # Laravel Scheduler Service
    scheduler:
        build: # Same build as app
            context: .
            dockerfile: docker/php/Dockerfile # PRODUCTION Dockerfile
            args:
                UID: ${UID:-1000}
                GID: ${GID:-1000}
                # APP_ENV: production
        container_name: propertylivewire-scheduler
        restart: unless-stopped
        working_dir: /var/www/html
        # Use flock for better locking than simple sleep loop, prevents overlapping runs
        command: |
            sh -c "while true; do flock -n /var/run/scheduler.lock -c 'php artisan schedule:run --verbose --no-interaction' || echo 'Scheduler already running'; sleep 60; done"
        volumes: # Similar considerations as 'app' service
            - ./:/var/www/html
        environment: # Inherit necessary vars
            APP_ENV: production
            APP_DEBUG: "false"
            APP_KEY: ${APP_KEY}
            DB_CONNECTION: mysql
            DB_HOST: db
            DB_DATABASE: ${DB_DATABASE:-propertylivewire}
            DB_USERNAME: ${DB_USERNAME:-sail}
            DB_PASSWORD: ${DB_PASSWORD_SECRET:-secret}
            REDIS_HOST: redis
            REDIS_PORT: 6379
        networks:
            - propertylivewire-network
        depends_on: # Needs code, db, and redis
            app:
                condition: service_started
            db:
                condition: service_healthy
            redis:
                condition: service_healthy

# Networks Definition
networks:
    propertylivewire-network:
        driver: bridge
        name: propertylivewire-network # Explicitly name the network

# Volumes Definition
volumes:
    propertylivewire-db-data:
        driver: local
        name: propertylivewire-db-data # Explicitly name the volume
    propertylivewire-redis-data:
        driver: local
        name: propertylivewire-redis-data # Explicitly name the volume

# Secrets Definition (Example using files)
# In production, these files should be managed securely by the deployment system
secrets:
    db_password:
        file: ./docker/secrets/db_password.txt # Path relative to docker-compose.yml
    db_root_password:
        file: ./docker/secrets/db_root_password.txt
    # Add other secrets like REDIS_PASSWORD if used
